#include "latticeview.h"
#include <stdlib.h> //for drand48()
#include <stdio.h> // for sprintf()
#include<ctime> //for time() in srand
#include<fstream> //for file output

#define N 100		        //Lateral number of cells
#define ImageWidth 1000  //image width
#define ImageHeight 1000 //image height
#define no_seeds 100

using namespace std;

void update_lattice(int i,int j,int t,int *label,int *lat)
{
	int id = i+j*N;
	lat[id] = 3; //burned out-black

	if(i!=0 && lat[id-1] == 1) //left lattice
	{
				label[id-1] = t; 
				lat[id-1] = 2;
	}
	if(i!=N-1 && lat[id+1] == 1) //right lattice
	{
				label[id+1] = t;
				lat[id+1] = 2;
	}
	if(j!=N-1 && lat[id+N] == 1) //bottom lattice
			{
				label[id+N] = t;
				lat[id+N] = 2;
			}
	if(j!=0 && lat[id-N] == 1) //top lattice
			{
				label[id-N] = t;
				lat[id-N] = 2;
			}
}

int main()
{
	int lat[N*N]={0},label[N*N]={0},chk_burn = 0, count = 0, count_span[no_seeds],time_step,no = 0,short_path[no_seeds],fire_time[no_seeds];
	//float frac=0, avg_path=0, avg_fire_time=0; // the random no generated by drand, which has to be compared with p (for occupation)
	double p_cell,p = 0.53,frac=0.0, avg_path=0.0, avg_fire_time=0.0;
	ofstream myfile_1,myfile_2,myfile_3;
	myfile_1.open ("frac_perc_100.dat",ios::app);
	myfile_2.open("avg_fire_100.dat",ios::app);
	myfile_3.open("short_path_100.dat",ios::app);
	cout<<"Spanning cluster (0/1),"<<" "<<"Shortest path time,"<<" "<<"Fire time"<<endl;
	srand48(time(NULL));
	while(p <= 0.65) //varying the occupation probability
	{
		frac=0.0, avg_path=0.0, avg_fire_time=0.0;
		no = 0;
		while (no < no_seeds) //number of seed measurements
		{		
			time_step = 1; //number of time steps
			count = 0; //change the value of count (to count if spanning cluster has been achieved or not)
			//Colouring the occupied sites as green - same as in Task 1	
			for(int i=0; i < N; i++)
				for(int j=0; j < N; j ++)
					{
						p_cell = drand48(); //random no generation
						if (p_cell < p)
							{
								lat[i+j*N] = 1; //occupied cells - green 
								label[i+j*N] = 1; //first time step
							}
						else
						{
							lat[i+j*N] = 0; //empty cells - white 
							label[i+j*N] = 0; //first time step
						}
					}

			for(int i=0;i < N; i++)	
			{
				if(lat[i] == 1)		
				{
					lat[i] = 2; //All cells in the top line will be 2 (burned initially)
					label[i] = 2; //Time step = 2
					time_step = 2;
				}
			}
	
			do
			{			
				chk_burn = 0;		
				time_step++;
				for(int j=0; j < N; j++)
					for(int i=0; i < N; i++)
						if( lat[i+j*N] == 2 && label[i+j*N]!=time_step) //burn the neighbors of burning lattices
						{
							update_lattice(i,j,time_step,label,lat);
							chk_burn = 1;
							if(j == N-1 && count!=1)
							{
								//cout<<"spanning cluster has reached within \t "<<time_step-1<<"\t time steps (shortest path)"<<endl;
								short_path[no] = time_step - 1;
								count = 1;
							}
						}			

			}while(chk_burn == 1);

			if(count==0)
				count_span[no] = 0;
			else
			{
				count_span[no] = 1;
			}
			fire_time[no] = time_step - 1;
			no++;
			//cout<<"Details of measurement no: "<<no<<" "<<count_span[no-1]<<" "<<short_path[no-1]<<" "<<fire_time[no-1]<<endl;
		}
		for(int i=0; i<no_seeds; i++)
		{	
			frac+= count_span[i];
			avg_path+=short_path[i];
			avg_fire_time+=fire_time[i];
		}
		cout<<"Details of lattice with p = "<<p<<endl;
		cout<<"Fraction of samples with percolative cluster = "<<  frac/(double) no_seeds<<endl;
		cout<<"Average shortest path = "<< avg_path/(double)no_seeds<<endl;
		cout<<"Average time of the fire = "<<avg_fire_time/(double)no_seeds<<endl;
		myfile_1<< p << " "<<frac/(double)no_seeds <<endl;
		myfile_3<< p << " "<< avg_path/(double)no_seeds<<endl;
		myfile_2<< p << " "<< avg_fire_time/(double)no_seeds<<endl;
		p = p + (double) 0.001;
	}
	myfile_1.close();
	myfile_2.close();
	myfile_2.close();	
	return 0;
}
